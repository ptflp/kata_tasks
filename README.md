# Требования к выполнению задач
Должно быть решено:
- 15 easy
- 10 medium

Так же, задачи должны проходить проверку на leetcode, кнопка submit по ссылке в конце задачи.

Задачи разместить по следующему пути ``` /module3/leetcode/easy/1.go ``` и ``` /module3/leetcode/medium/1.go ```, где 1 это номер задачи

# Задачи уровня easy
## 1. N-th Tribonacci Number
Последовательность Трибоначчи Tn определяется следующим образом:

T0 = 0, T1 = 1, T2 = 1 и Tn + 3 = Tn + Tn + 1 + Tn + 2 для n> = 0.

Дано n, верните значение Tn.

Пример 1:

Input: n = 4

Output: 4

Объяснение:

T\_3 = 0 + 1 + 1 = 2

T\_4 = 1 + 1 + 2 = 4

Пример 2:

Input: n = 25

Output: 1389537

Ограничения:

- 0 <= n <= 37
- Ответ гарантированно поместится в 32-битное целое число, т.е. ответ <= 2 ^ 31 - 1.

```go
func tribonacci(n int) int {

}
```

<https://leetcode.com/problems/n-th-tribonacci-number/>

## 2. Объединение массива
Дан массив целых чисел nums длиной n. Вы должны создать массив ans длиной 2n, где ans[i] == nums[i] и ans[i + n] == nums[i] для 0 <= i < n (с индексацией 0).

ans является слиянием двух массивов nums.

Верните массив ans.

Пример 1:

Input: nums = [1,2,1]

Output: [1,2,1,1,2,1]

Объяснение: Массив ans формируется следующим образом:

\- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]

\- ans = [1,2,1,1,2,1]

Пример 2:

Input: nums = [1,3,2,1]

Output: [1,3,2,1,1,3,2,1]

Объяснение: Массив ans формируется следующим образом:

\- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]

\- ans = [1,3,2,1,1,3,2,1]

Constraints:

- n == nums.length
- 1 <= n <= 1000
- 1 <= nums[i] <= 1000

```go
func getConcatenation(nums []int) []int {

}
```

<https://leetcode.com/problems/concatenation-of-array/>

## 3. Преобразование температуры
Вам дается неотрицательное дробное число с двумя знаками после запятой, указывающее температуру в градусах Цельсия.

Вы должны преобразовать Цельсий в Кельвины и Фаренгейты и вернуть его в виде массива ans = [kelvin, fahrenheit].

Верните массив ans. Ответы в пределах 10-5 от реального ответа будут приняты.

Обратите внимание:

Kelvin = Celsius + 273.15

Fahrenheit = Celsius \* 1.80 + 32.00

Пример 1:

Input: celsius = 36.50

Output: [309.65000,97.70000]

Объяснение: Температура при 36,50 Цельсия переведена в Кельвины равна 309,65, а в Фаренгейты - 97,70.

Пример 2:

Input: celsius = 122.11

Output: [395.26000,251.79800]

Объяснение: Температура при 122,11 Цельсия преобразована в Кельвинах составляет 395,26, а в Фаренгейтах - 251,798.

Constraints:

- 0 <= celsius <= 1000

```go
func convertTemperature(celsius float64) []float64 {

}
```

<https://leetcode.com/problems/convert-the-temperature/>

## 4. Построить массив из перестановки
Дана нулевая перестановка nums (с нулевым индексом), создайте массив ans одинаковой длины, где ans[i] = nums[nums[i]] для каждого 0 <= i < nums.length и верните его. Нулевая перестановка nums - это массив уникальных целых чисел от 0 до nums.length - 1 (включительно).

Пример 1:

Input: nums = [0,2,1,5,3,4]

Output: [0,1,2,4,5,3]

Объяснение: Массив ans строится следующим образом: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]] = [0,1,2,4,5,3]

Пример 2:

Input: nums = [5,0,1,2,3,4]

Output: [4,5,0,1,2,3]

Объяснение: Массив ans строится следующим образом: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]] = [4,5,0,1,2,3]

Ограничения:

• 1 <= nums.length <= 1000

• 0 <= nums[i] < nums.length

• Элементы в nums уникальны.

```go
func buildArray(nums []int) []int {

}
```

<https://leetcode.com/problems/build-array-from-permutation/>

## 5. Количество матчей в турнире

Дано целое число n - количество команд в турнире с необычными правилами:

Если текущее количество команд четное, то каждая команда играет в паре с другой командой. Всего сыграно n / 2 матчей, и n / 2 команды проходят на следующий раунд. Если текущее количество команд нечетное, то одна команда проходит дальше в турнире случайным образом, а остальные команды играют в паре. Всего сыграно (n-1) / 2 матчей, и (n-1) / 2 + 1 команда проходит на следующий раунд.

Вернуть количество матчей, сыгранных в турнире, пока не будет определен победитель.

Пример 1:

Input: n = 7

Output: 6

Объяснение: Детали турнира:

1-й раунд: команды = 7, матчей = 3, и 4 команды проходят дальше.

2-й раунд: команды = 4, матчей = 2, и 2 команды проходят дальше.

3-й раунд: команды = 2, матчей = 1, и 1 команда объявляется победителем. Всего сыграно матчей = 3 + 2 + 1 = 6.


Пример 2:

Input: n = 14

Output: 13

Объяснение: Детали турнира:

1-й раунд: команды = 14, матчей = 7, и 7 команд проходят дальше.

2-й раунд: команды = 7, матчей = 3, и 4 команды проходят дальше.

3-й раунд: команды = 4, матчей = 2, и 2 команды проходят дальше.

4-й раунд: команды = 2, матчей = 1, и 1 команда объявляется победителем. Всего сыграно матчей = 7 + 3 + 2 + 1 = 13.

Ограничения:

1 <= n <= 200

```go
func numberOfMatches(n int) int {
```

<https://leetcode.com/problems/count-of-matches-in-tournament/>


## 6. Уникальные слова Морзе

Международная азбука Морзе определяет стандартное кодирование, где каждая буква отображается в серию точек и тире, следующим образом:

'a' отображается как ".-",

'b' отображается как "-...",

'c' отображается как "-.-.", и так далее.

Для удобства, ниже приведена полная таблица для 26 букв английского алфавита:

[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]

Дан массив строк words, каждое из которых может быть записано как конкатенация кода Морзе для каждой буквы.

Например, "cab" можно записать как "-.-..--...", что является конкатенацией "-.-.", ".-" и "-...". Мы будем называть такую конкатенацию преобразованием слова.

Вернуть количество различных преобразований среди всех слов, которые у нас есть.

Пример 1:

Input: words = ["gin","zen","gig","msg"]

Output: 2

Объяснение: Преобразование каждого слова выглядит так:

"gin" -> "--...-."

"zen" -> "--...-."

"gig" -> "--...--."

"msg" -> "--...--."

Существует 2 различных преобразования: "--...-." и "--...--.".

Пример 2:

Input: words = ["a"]

Output: 1

Ограничения:

1 <= words.length <= 100

1 <= words[i].length <= 12

words[i] состоит из строчных букв английского алфавита.

```go
func uniqueMorseRepresentations(words []string) int {

}
```

<https://leetcode.com/problems/unique-morse-code-words/>

## 7. Защита IP-адреса
Дан действительный (IPv4) IP-адрес, вернуть защищенную версию этого IP-адреса.

Защищенный IP-адрес заменяет каждую точку "." с "[.]"

Пример 1:

Input: адрес = "1.1.1.1"

Output: "1[.]1[.]1[.]1"

Пример 2:

Input: адрес = "255.100.50.0"

Output: "255[.]100[.]50[.]0"

Ограничения:

Данный адрес является действительным адресом IPv4.

```go
func defangIPaddr(address string) string {

}
```

<https://leetcode.com/problems/defanging-an-ip-address/>

## 8. K-й пропущенный положительный номер

Дан массив arr положительных целых чисел, отсортированных в строго возрастающем порядке, и целое число k.

Верните k-ое положительное целое число, которое отсутствует в этом массиве.

Пример 1:

Input: arr = [2,3,4,7,11], k = 5

Output: 9

Объяснение:

Отсутствующие положительные целые числа: [1,5,6,8,9,10,12,13, ...]. Пятое отсутствующее положительное целое число - 9.

Пример 2:

Input: arr = [1,2,3,4], k = 2

Output: 6

Объяснение:

Отсутствующие положительные целые числа - [5,6,7,...]. Второе пропущенное положительное целое число - 6.

Ограничения:

1 <= arr.length <= 1000

1 <= arr[i] <= 1000

1 <= k <= 1000

arr[i] < arr[j] for 1 <= i < j <= arr.length

```go
func findKthPositive(arr []int, k int) int {
    
}
```

<https://leetcode.com/problems/kth-missing-positive-number/>

## 9. Финальное значение переменной после выполнения операций
Есть язык программирования с только четырьмя операциями и одной переменной X:

++X и X ++ увеличивает значение переменной X на 1.

--X и X -- уменьшает значение переменной X на 1.

Изначально значение X равно 0.

Дан массив строк operations, содержащий список операций, возвращает финальное значение X после выполнения всех операций.

Пример 1:

Input: operations = ["--X","X ++","X ++"]

Output: 1

Объяснение: Операции выполняются следующим образом:

Изначально X = 0.

--X: X уменьшается на 1, X = 0 - 1 = -1.

X ++: X увеличивается на 1, X = -1 + 1 = 0.

X ++: X увеличивается на 1, X = 0 + 1 = 1.

Пример 2:

Input: operations = ["++X","++X","X ++"]

Output: 3

Объяснение: Операции выполняются следующим образом:

Изначально X = 0.

++X: X увеличивается на 1, X = 0 + 1 = 1.

++X: X увеличивается на 1, X = 1 + 1 = 2.

X ++: X увеличивается на 1, X = 2 + 1 = 3.

Пример 3:

Input: operations = ["X++","++X","--X","X--"]

Output: 0

Объяснение: Операции выполняются следующим образом:

Изначально, X = 0.

X++: X увеличивается на 1, X = 0 + 1 = 1.

++X: X увеличивается на 1, X = 1 + 1 = 2.

--X: X уменьшается на 1, X = 2 - 1 = 1.

X--: X уменьшается на 1, X = 1 - 1 = 0.

Ограничения:

1 <= operations.length <= 100

operations[i] будет либо "++X", "X++", "--X", либо "X--".

```go
func finalValueAfterOperations(operations []string) int {

}
```

<https://leetcode.com/problems/final-value-of-variable-after-performing-operations/>

## 10. Перетасовать массив
Дан массив nums, состоящий из 2n элементов в виде [x1,x2,...,xn,y1,y2,...,yn].

Верните массив в виде [x1,y1,x2,y2,...,xn,yn].

Пример 1:

Input: nums = [2,5,1,3,4,7], n = 3

Output: [2,3,5,4,1,7]

Объяснение:

Поскольку x1=2, x2=5, x3=1, y1=3, y2=4, y3=7, то ответ равен [2,3,5,4,1,7].

Пример 2:

Input: nums = [1,2,3,4,4,3,2,1], n = 4

Output: [1,4,2,3,3,2,4,1]

Пример 3:

Input: nums = [1,1,2,2], n = 2

Output: [1,2,1,2]

Ограничения:

1 <= n <= 500

nums.length == 2n

1 <= nums[i] <= 10^3

```go
func shuffle(nums []int, n int) []int {

}
```


<https://leetcode.com/problems/shuffle-the-array/>

## 11. Текущее значение суммы в одномерном массиве
Дан массив nums. Мы определяем текущее значение суммы массива как runningSum[i] = sum(nums [0]…nums [i]).

Верните текущее значение суммы nums.

Пример 1:

Input: nums = [1,2,3,4]

Output: [1,3,6,10]

Объяснение: Текущее значение суммы получается следующим образом: [1, 1+2, 1+2+3, 1+2+3+4].

Пример 2:

Input: nums = [1,1,1,1,1]

Output: [1,2,3,4,5]

Объяснение: Текущее значение суммы получается следующим образом: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].

Пример 3:

Input: nums = [3,1,2,10,1]

Output: [3,4,6,16,17]

Ограничения:

1 <= nums.length <= 1000

-10^6 <= nums [i] <= 10^6

```go
func runningSum(nums []int) []int {

}
```

<https://leetcode.com/problems/running-sum-of-1d-array/>

## 12. Количество хороших пар
Дан массив целых чисел nums. Верните количество хороших пар.

Пара (i, j) называется хорошей, если nums [i] == nums [j] и i <j.

Пример 1:

Input: nums = [1,2,3,1,1,3]

Output: 4

Объяснение: Есть 4 хорошие пары (0,3), (0,4), (3,4), (2,5), с нулевым индексом.

Пример 2:

Input: nums = [1,1,1,1]

Output: 6

Объяснение: Каждая пара в массиве является хорошей.

Пример 3:

Input: nums = [1,2,3]

Output: 0

Ограничения:

1 <= nums.length <= 100

1 <= nums [i] <= 100

```go
func numIdenticalPairs(nums []int) int {

}
```

<https://leetcode.com/problems/number-of-good-pairs/>

## 13. Драгоценности и камни
Вам даны строки jewels, представляющие типы камней, которые являются драгоценностями, и камни, представляющие stones, которые у вас есть. Каждый символ в stones является типом камня, который у вас есть. Вы хотите знать, сколько из камней, которые у вас есть, также являются драгоценностями.

Буквы чувствительны к регистру, поэтому «a» считается разным типом камня от «A».

Пример 1:

Input: jewels = "aA", stones = "aAAbbbb"

Output: 3

Пример 2:

Input: jewels = "z", stones = "ZZ"

Output: 0

Ограничения:

1 <= jewels.length, stones.length <= 50

jewels и stones состоят только из английских букв.

Все символы jewels уникальны.

```go
func numJewelsInStones(jewels string, stones string) int {

}
```

<https://leetcode.com/problems/jewels-and-stones/>

## 14. Богатство самого богатого клиента
Вам дана матрица целых чисел accounts, где accounts[i][j] - это сумма денег, которые имеет i-й клиент в j-м банке. Верните богатство самого богатого клиента.

Богатство клиента - это сумма денег, которые он имеет во всех своих банковских счетах. Самым богатым клиентом считается клиент с максимальным богатством.

Пример 1:

Input: accounts = [[1,2,3],[3,2,1]]

Output: 6

Объяснение:

1-й клиент имеет богатство = 1 + 2 + 3 = 6

2-й клиент имеет богатство = 3 + 2 + 1 = 6

Оба клиента считаются самыми богатыми с богатством 6 каждый, поэтому возвращаем 6.

Пример 2:

Input: accounts = [[1,5],[7,3],[3,5]]

Output: 10

Объяснение:

1-й клиент имеет богатство = 6

2-й клиент имеет богатство = 10

3-й клиент имеет богатство = 8

2-й клиент является самым богатым с богатством 10.

Пример 3:

Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]

Output: 17

Ограничения:

m == accounts.length

n == accounts[i].length

1 <= m, n <= 50

1 <= accounts[i][j] <= 100

```go
func maximumWealth(accounts [][]int) int {

}
```

<https://leetcode.com/problems/richest-customer-wealth/>

## 15. Дизайн парковочной системы
Спроектировать парковочную систему для парковки. На парковке есть три вида парковочных мест: большие, средние и маленькие, с фиксированным количеством мест для каждого размера.

Реализуйте класс ParkingSystem:

ParkingSystem(int big, int medium, int small) Инициализирует объект класса ParkingSystem. Количество мест для каждого парковочного места указано в конструкторе.

bool addCar(int carType) Проверяет, есть ли парковочное место типа carType для автомобиля, который хочет попасть на стоянку. carType может быть трех видов: большой, средний или маленький, которые представлены цифрами 1, 2 и 3 соответственно. **Автомобиль может парковаться только на парковочном месте своего** типа автомобиля carType. Если места нет, верните false, в противном случае припаркуйте машину на месте такого размера и верните true.

Пример 1:

Input

["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]

[[1, 1, 0], [1], [2], [3], [1]]

Output

[null, true, true, false, false]

Объяснение

ParkingSystemparkingSystem = новая ParkingSystem(1, 1, 0);

parkingSystem.addCar(1); // возвращаем true, потому что есть 1 свободный слот для большой машины

parkingSystem.addCar(2); // вернем true, потому что есть 1 свободный слот для средней машины

parkingSystem.addCar(3); // вернем false, потому что нет свободного слота для маленькой машины

parkingSystem.addCar(1); // вернем false, потому что нет свободного места для большой машины. Оно уже занято.

Ограничения:

0 <= большой, средний, маленький <= 1000

carType — 1, 2 или 3.

В addCar будет сделано не более 1000 запросов.

```go
type ParkingSystem struct {



}

func Constructor(big int, medium int, small int) ParkingSystem {



}

func (this \*ParkingSystem) AddCar(carType int) bool {



}
```

<https://leetcode.com/problems/design-parking-system/>


# Задачи уровня Medium
## 1. Сумма самых глубоких листьев.
Дан root дерево бинарных данных, верните сумму значений его самых глубоких листьев.

Пример 1:


Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]

Output: 15

Пример 2:

Input: root = [,,8,,,,9,null,,,null,null,null,]

Output: 19

Constraints:

- Количество узлов в дереве находится в диапазоне [1, 104].
- 1 <= Node.val <= 100

<https://leetcode.com/problems/deepest-leaves-sum/>
## 2. Отсортируйте студентов по их K-му баллу.
Дана класс с m студентами и n экзаменами. Вам дана матрица целых чисел 0-индексированных m x n, где каждая строка представляет одного студента, а score [i] [j] обозначает балл, который i-тый студент получил на j-том экзамене. Матрица оценок содержит только уникальные целые числа.

Вам также дано целое число k. Отсортируйте студентов (т. e. Строки матрицы) по их баллам в k-ом (0-индексированном) экзамене от высшего к низшему.

Верните матрицу после сортировки.

Пример 1:

Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2

Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]

Объяснение: На диаграмме выше S обозначает студента, а E - экзамен.

\- Студент с индексом 1 получил 11 баллов в экзамене 2, что является самым высоким результатом, поэтому он занял первое место.

\- Студент с индексом 0 получил 9 баллов в экзамене 2, что является вторым по высоте результатом, поэтому он занял второе место.

\- Студент с индексом 2 получил 3 балла в экзамене 2, что является самым низким результатом, поэтому он занял третье место.

Пример 2:

Input: score = [[3,4],[5,6]], k = 0

Output: [[5,6],[3,4]]

Объяснение: На диаграмме выше S обозначает студента, а E - экзамен.

\- Студент с индексом 1 получил 5 баллов в экзамене 0, что является самым высоким результатом, поэтому он занял первое место.

\- Студент с индексом 0 получил 3 балла в экзамене 0, что является самым низким результатом, поэтому он занял второе место.

Constraints:

- m == score.length
- n == score[i].length
- 1 <= m, n <= 250
- 1 <= score[i][j] <= 105
- score consists of distinct integers.
- 0 <= k < n

<https://leetcode.com/problems/sort-the-students-by-their-kth-score/>
## 3. Объединить узлы
Вам дан заголовок связанного списка, который содержит ряд целых чисел, разделенных нулями. Начало и конец связного списка будет иметь Node.val == 0.

Для каждых двух последовательных нулей объединяйте все узлы, лежащие между ними в один узел, чье значение является суммой всех объеденных узлов. Измененный список не должен содержать никаких нулей.

Верните заголовок измененного связного списка.

Пример 1:

Input: head = [0,3,1,0,4,5,2,0]

Output: [4,11]

Объяснение: Вышеуказанная фигура представляет собой связанный список. Измененный список содержит:

\- Сумму узлов, помеченных зеленым: 3 + 1 = 4.

\- Сумму узлов, помеченных красным: 4 + 5 + 2 = 11.

Пример 2:

Input: head = [0,1,0,3,0,2,2,0]

Output: [1,3,4]

Объяснение:

Вышеуказанная фигура представляет собой данный связанный список. Измененный список содержит:

\- Сумму узлов, отмеченных зеленым цветом: 1 = 1.

\- Сумму узлов, отмеченных красным цветом: 3 = 3.

\- Сумму узлов, отмеченных желтым цветом: 2 + 2 = 4.

Constraints:

- Количество узлов в списке находится в диапазоне [3, 2 \* 105].
- 0 <= Node.val <= 1000
- Нет двух последовательных узлов с Node.val == 0.
- Начало и конец связного списка имеют Node.val == 0.

<https://leetcode.com/problems/merge-nodes-in-between-zeros/>
## 4. Бинарное дерево в большую сумму дерева.
Дано root звено бинарного поискового дерева (BST), преобразуйте его в большее дерево так, чтобы каждый ключ исходного BST был изменен на исходный ключ плюс сумма всех ключей, больших исходного ключа в BST.

В качестве напоминания, бинарное поисковое дерево - это дерево, которое удовлетворяет следующим ограничениям:

- Левое поддерево узла содержит только узлы с ключами меньше ключа узла.
- Правое поддерево узла содержит только узлы с ключами больше ключа узла.
- Оба поддерева должны быть также бинарными поисковыми деревьями.

Пример 1:

Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]

Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

Пример 2:

Input: root = [0,null,1]

Output: [1,null,1]

Constraints:

- Диапазон значений узлов находится в диапазоне [1, 100]
- 0 <= Node.val <= 100
- Все значения в дереве уникальны.

<https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/>

## 5. Максимальная сумма двух звеньев связанного списка
В связанном списке размера n, где n является четным,  i-й узел (с 0 индексом) связанного списка известен как близнец(twin) (n-1-i) узла, если 0 <= i <= (n / 2) - 1.

- Например, если n = 4, то узел 0 является близнецом узла 3, а узел 1 является близнецом узла 2. Это единственные узлы с близнецами для n = 4.

Сумма близнецов(twin sum) определяется как сумма узла и его близнеца.

Дан заголовок связанного списка с четной длиной, верните максимальную сумму близнецов связанного списка.

Пример 1:

Input: head = [5,4,2,1]

Output: 6

Объяснение:

Узлы 0 и 1 являются близнецами узлов 3 и 2 соответственно. Все имеют сумму близнецов = 6. В связанном списке нет других узлов с близнецами. Таким образом, максимальная сумма близнецов в связанном списке составляет 6.

Пример 2:


Input: head = [4,2,2,3]

Output: 7

Объяснение:

Узлы с двойниками в этом связанном списке:

\- Узел 0 является двойником узла 3 с двойной суммой 4 + 3 = 7.

\- Узел 1 является двойником узла 2 с двойной суммой 2 + 2 = 4.

Таким образом, максимальная двойная сумма связанного списка равна max(7, 4) = 7.

Пример 3:

Input: head = [1,100000]

Output: 100001

Объяснение:

В связанном списке с двойным суммой 1 + 100000 = 100001 есть только один узел с двойником.

Constraints:

- Число узлов в списке является четным целым числом в диапазоне [2, 105].
- 1 <= Node.val <= 105

<https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/>

## 6. Максимальное бинарное дерево
Вам дан массив целых чисел nums без дубликатов. Максимальное бинарное дерево может быть построено рекурсивно из nums с помощью следующего алгоритма:

Создайте корневой узел, значение которого является максимальным значением в nums.

Рекурсивно постройте левое поддерево на подмассиве префикса левее максимального значения.

Рекурсивно постройте правое поддерево на подмассиве суффикса правее максимального значения.

Верните максимальное бинарное дерево, построенное из nums.

Пример 1:

Input: nums = [3,2,1,6,0,5]

Output: [6,3,5,null,2,0,null,null,1]

Объяснение: Рекурсивные вызовы выглядят следующим образом:

\- Наибольшее значение в [3,2,1,6,0,5] является 6. Левый префикс равен [3,2,1] и правый суффикс равен [0,5].

\- Наибольшее значение в [3,2,1] является 3. Левый префикс равен [] и правый суффикс равен [2,1].

\- Пустой массив, поэтому нет детей.

\- Наибольшее значение в [2,1] является 2. Левый префикс равен [] и правый суффикс равен [1].

\- Пустой массив, поэтому нет детей.

\- Только один элемент, поэтому ребенок - узел со значением 1.

\- Наибольшее значение в [0,5] является 5. Левый префикс равен [0] и правый суффикс равен [].

\- Только один элемент, поэтому ребенок - узел со значением 0.

\- Пустой массив, поэтому нет детей.

Пример  2:

Input: nums = [3,2,1]

Output: [3,null,2,null,1]

Constraints:

- 1 <= nums.length <= 1000
- 0 <= nums[i] <= 1000
- All integers in nums are unique.

<https://leetcode.com/problems/maximum-binary-tree/>

## 7. Балансировка бинарного поискового дерева
Дано корневое значение бинарного поискового дерева. Верните сбалансированное бинарное поисковое дерево с теми же значениями узлов. Если есть более одного ответа, верните любой из них.

Бинарное поисковое дерево считается сбалансированным, если глубина двух поддеревьев каждого узла никогда не отличается более чем на 1.

Пример 1:

Input: root = [1,null,2,null,3,null,4,null,null]

Output: [2,1,3,null,null,null,4]

Explanation: Это не единственный правильный ответ, [3,1,4,null,2] также правильный.

Пример 2:

Input: root = [2,1,3]

Output: [2,1,3]

Constraints:

- Количество узлов в дереве находится в диапазоне [1, 104].
- 1 <= Node.val <= 105

<https://leetcode.com/problems/balance-a-binary-search-tree/>

## 8. Минимальное количество вершин для достижения всех узлов
Дан ориентированный ациклический граф, с n вершинами, пронумерованными от 0 до n-1, и массив ребер, где edges [i] = [fromi, toi] представляет собой направленное ребро от узла fromi к узлу toi .

Найдите самый маленький набор вершин, из которых достижимы все узлы в графе. Гарантируется существование уникального решения.

Обратите внимание, что вы можете вернуть вершины в любом порядке.

Пример 1:

Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]

Output: [0,3]

Объяснение: Невозможно достичь всех узлов из одной вершины. От 0 мы можем достичь [0,1,2,5]. От 3 мы можем достичь [3,4,2,5]. Так что мы выводим [0,3].].

Пример 2:

Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]

Output: [0,2,3]

Объяснение: Обратите внимание, что вершины 0, 3 и 2 недостижимы из любой другой вершины, поэтому мы должны их включить. Также любая из этих вершин может достичь узлов 1 и 4.



Constraints:

- 2 <= n <= 10^5
- 1 <= edges.length <= min(10^5, n \* (n - 1) / 2)
- edges[i].length == 2
- 0 <= fromi, toi < n
- All pairs (fromi, toi) are distinct.

<https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/>

## 9. Арифметические подмассивы
Последовательность чисел называется арифметической, если она состоит как минимум из двух элементов, а разница между каждыми двумя соседними элементами одинакова. Более формально, последовательность s является арифметической, если и только если s[i + 1] - s[i] == s[1] - s[0] для всех допустимых i.

Например, это арифметические последовательности:

Следующая последовательность не является арифметической:

Вам дан массив из n целых чисел, nums и два массива из m целых чисел каждый, l и r, представляющий m диапазонов запросов, где i-й запрос является диапазоном [l [i], r [i]]. Все массивы имеют индекс 0.

Верните список булевых элементов ответа, где answer [i] является true, если подмассив nums [l [i]], nums [l [i] + 1], ..., nums [r [i]] можно переупорядочить для формирования арифметической последовательности, и false в противном случае.

Пример 1:

Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]

Output: [true,false,true]

Объяснение:

В 0-м запросе подмассив состоит из [4,6,5]. Это можно переставить как [6,5,4], что является арифметической прогрессией.

В 1-м запросе подмассив состоит из [4,6,5,9]. Это не может быть переставлено в арифметическую прогрессию.

Во 2-м запросе подмассив состоит из [5,9,3,7]. Это может быть переставлено как [3,5,7,9], что является арифметической прогрессией.Arithmetic Subarrays

Пример 2:

Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]

Output: [false,true,false,false,true,true]

Constraints:

- n == nums.length
- m == l.length
- m == r.length
- 2 <= n <= 500
- 1 <= m <= 500
- 0 <= l[i] < r[i] < n
- -105 <= nums[i] <= 105

<https://leetcode.com/problems/arithmetic-subarrays/>

## 10. Возможности буквенных плиток.
У вас есть n плиток, на каждой из которых напечатана одна буква tiles[i].

Верните количество возможных непустых последовательностей букв, которые вы можете составить, используя буквы, напечатанные на этих плитках.

Пример 1:

Input: tiles = "AAB"

Output: 8

Объяснение : Возможные последовательности: "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA".

Пример 2:

Input: tiles = "AAABBC"

Output: 188

Пример 3:

Input: tiles = "V"

Output: 1

Constraints:

- 1 <= tiles.length <= 7
- Набор плиток состоит из заглавных букв английского алфавита..

<https://leetcode.com/problems/letter-tile-possibilities/>




