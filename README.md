# Требования к выполнению задач
Должно быть решено:
- 24 easy
- 16 medium

Так же, задачи должны проходить проверку на leetcode, кнопка submit по ссылке в конце задачи.

Задачи разместить по следующему пути ```sh /module3/leetcode/easy/1 ``` и ```sh /module3/leetcode/medium/1 ```, где 1 это номер задачи

# Задачи уровня easy
## 1. N-th Tribonacci Number
Последовательность Трибоначчи Tn определяется следующим образом:

T0 = 0, T1 = 1, T2 = 1 и Tn + 3 = Tn + Tn + 1 + Tn + 2 для n> = 0.

Дано n, верните значение Tn.

Пример 1:

Input: n = 4

Output: 4

Объяснение:

T\_3 = 0 + 1 + 1 = 2

T\_4 = 1 + 1 + 2 = 4

Пример 2:

Input: n = 25

Output: 1389537

Ограничения:

- 0 <= n <= 37
- Ответ гарантированно поместится в 32-битное целое число, т.е. ответ <= 2 ^ 31 - 1.

```go
func tribonacci(n int) int {

}
```

<https://leetcode.com/problems/n-th-tribonacci-number/>
## 2. Объединение массива
Дан массив целых чисел nums длиной n. Вы должны создать массив ans длиной 2n, где ans[i] == nums[i] и ans[i + n] == nums[i] для 0 <= i < n (с индексацией 0).

ans является слиянием двух массивов nums.

Верните массив ans.

Пример 1:

Input: nums = [1,2,1]

Output: [1,2,1,1,2,1]

Объяснение: Массив ans формируется следующим образом:

\- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]

\- ans = [1,2,1,1,2,1]

Пример 2:

Input: nums = [1,3,2,1]

Output: [1,3,2,1,1,3,2,1]

Объяснение: Массив ans формируется следующим образом:

\- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]

\- ans = [1,3,2,1,1,3,2,1]

Constraints:

- n == nums.length
- 1 <= n <= 1000
- 1 <= nums[i] <= 1000

```go
func getConcatenation(nums []int) []int {

}
```

<https://leetcode.com/problems/concatenation-of-array/>
## 3. Преобразование температуры
Вам дается неотрицательное дробное число с двумя знаками после запятой, указывающее температуру в градусах Цельсия.

Вы должны преобразовать Цельсий в Кельвины и Фаренгейты и вернуть его в виде массива ans = [kelvin, fahrenheit].

Верните массив ans. Ответы в пределах 10-5 от реального ответа будут приняты.

Обратите внимание:

Kelvin = Celsius + 273.15

Fahrenheit = Celsius \* 1.80 + 32.00

Пример 1:

Input: celsius = 36.50

Output: [309.65000,97.70000]

Объяснение: Температура при 36,50 Цельсия переведена в Кельвины равна 309,65, а в Фаренгейты - 97,70.

Пример 2:

Input: celsius = 122.11

Output: [395.26000,251.79800]

Объяснение: Температура при 122,11 Цельсия преобразована в Кельвинах составляет 395,26, а в Фаренгейтах - 251,798.

Constraints:

- 0 <= celsius <= 1000

```go
func convertTemperature(celsius float64) []float64 {

}
```

<https://leetcode.com/problems/convert-the-temperature/>
## 4. Построить массив из перестановки
Дана нулевая перестановка nums (с нулевым индексом), создайте массив ans одинаковой длины, где ans[i] = nums[nums[i]] для каждого 0 <= i < nums.length и верните его. Нулевая перестановка nums - это массив уникальных целых чисел от 0 до nums.length - 1 (включительно).

Пример 1:

Input: nums = [0,2,1,5,3,4]

Output: [0,1,2,4,5,3]

Объяснение: Массив ans строится следующим образом: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]] = [0,1,2,4,5,3]

Пример 2:

Input: nums = [5,0,1,2,3,4]

Output: [4,5,0,1,2,3]

Объяснение: Массив ans строится следующим образом: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]] = [4,5,0,1,2,3]

Ограничения:

• 1 <= nums.length <= 1000

• 0 <= nums[i] < nums.length

• Элементы в nums уникальны.

```go
func buildArray(nums []int) []int {

}
```

<https://leetcode.com/problems/build-array-from-permutation/>

## 5. Объединение массива
Дан массив целых чисел nums длиной n. Вы должны создать массив ans длиной 2n, где ans[i] == nums[i] и ans[i + n] == nums[i] для 0 <= i < n (с индексацией 0).

ans является слиянием двух массивов nums.

Верните массив ans.

Пример 1:

Input: nums = [1,2,1]

Output: [1,2,1,1,2,1]

Объяснение: Массив ans формируется следующим образом:

\- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]

\- ans = [1,2,1,1,2,1]

Пример 2:

Input: nums = [1,3,2,1]

Output: [1,3,2,1,1,3,2,1]

Объяснение: Массив ans формируется следующим образом:

\- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]

\- ans = [1,3,2,1,1,3,2,1]

Ограничения:

n == nums.length

1 <= n <= 1000

1 <= nums[i] <= 1000

```go
func getConcatenation(nums []int) []int {

}
```

<https://leetcode.com/problems/concatenation-of-array/>

## 6. Преобразование температуры
Вам дается неотрицательное дробное число с двумя знаками после запятой, указывающее температуру в градусах Цельсия.

Вы должны преобразовать Цельсий в Кельвины и Фаренгейты и вернуть его в виде массива ans = [kelvin, fahrenheit].

Верните массив ans. Ответы в пределах 10-5 от реального ответа будут приняты.

Обратите внимание:

Kelvin = Celsius + 273.15

Fahrenheit = Celsius \* 1.80 + 32.00

Пример 1:

Input: celsius = 36.50

Output: [309.65000,97.70000]

Объяснение: Температура при 36,50 Цельсия переведена в Кельвины равна 309,65, а в Фаренгейты - 97,70.

Пример 2:

Input: celsius = 122.11

Output: [395.26000,251.79800]

Объяснение: Температура при 122,11 Цельсия преобразована в Кельвинах составляет 395,26, а в Фаренгейтах - 251,798.

Ограничения:

0 <= celsius <= 1000

```go
func convertTemperature(celsius float64) []float64 {

}
```

<https://leetcode.com/problems/convert-the-temperature/>

## 7. Защита IP-адреса
Дан действительный (IPv4) IP-адрес, вернуть защищенную версию этого IP-адреса.

Защищенный IP-адрес заменяет каждую точку "." с "[.]"

Пример 1:

Input: адрес = "1.1.1.1"

Output: "1[.]1[.]1[.]1"

Пример 2:

Input: адрес = "255.100.50.0"

Output: "255[.]100[.]50[.]0"

Ограничения:

Данный адрес является действительным адресом IPv4.

```go
func defangIPaddr(address string) string {

}
```

<https://leetcode.com/problems/defanging-an-ip-address/>

## 8. Добавить два целых числа
Даны два целых числа num1 и num2, вернуть сумму двух целых чисел.

Пример 1:

Input: num1 = 12, num2 = 5

Output: 17

Объяснение: num1 равно 12, num2 равно 5, а их сумма равна 12 + 5 = 17, поэтому возвращается 17.

Пример 2:

Input: num1 = -10, num2 = 4

Output: -6

Объяснение: num1 + num2 = -6, поэтому возвращается -6.

Ограничения:

-100 <= num1, num2 <= 100

```go
func sum(num1 int, num2 int) int {

}
```

<https://leetcode.com/problems/add-two-integers/>

## 9. Финальное значение переменной после выполнения операций
Есть язык программирования с только четырьмя операциями и одной переменной X:

++X и X ++ увеличивает значение переменной X на 1.

--X и X -- уменьшает значение переменной X на 1.

Изначально значение X равно 0.

Дан массив строк operations, содержащий список операций, возвращает финальное значение X после выполнения всех операций.

Пример 1:

Input: operations = ["--X","X ++","X ++"]

Output: 1

Объяснение: Операции выполняются следующим образом:

Изначально X = 0.

--X: X уменьшается на 1, X = 0 - 1 = -1.

X ++: X увеличивается на 1, X = -1 + 1 = 0.

X ++: X увеличивается на 1, X = 0 + 1 = 1.

Пример 2:

Input: operations = ["++X","++X","X ++"]

Output: 3

Объяснение: Операции выполняются следующим образом:

Изначально X = 0.

++X: X увеличивается на 1, X = 0 + 1 = 1.

++X: X увеличивается на 1, X = 1 + 1 = 2.

X ++: X увеличивается на 1, X = 2 + 1 = 3.

Пример 3:

Input: operations = ["X++","++X","--X","X--"]

Output: 0

Объяснение: Операции выполняются следующим образом:

Изначально, X = 0.

X++: X увеличивается на 1, X = 0 + 1 = 1.

++X: X увеличивается на 1, X = 1 + 1 = 2.

--X: X уменьшается на 1, X = 2 - 1 = 1.

X--: X уменьшается на 1, X = 1 - 1 = 0.

Ограничения:

1 <= operations.length <= 100

operations[i] будет либо "++X", "X++", "--X", либо "X--".

```go
func finalValueAfterOperations(operations []string) int {

}
```

<https://leetcode.com/problems/final-value-of-variable-after-performing-operations/>

## 10. Перетасовать массив
Дан массив nums, состоящий из 2n элементов в виде [x1,x2,...,xn,y1,y2,...,yn].

Верните массив в виде [x1,y1,x2,y2,...,xn,yn].

Пример 1:

Input: nums = [2,5,1,3,4,7], n = 3

Output: [2,3,5,4,1,7]

Объяснение:

Поскольку x1=2, x2=5, x3=1, y1=3, y2=4, y3=7, то ответ равен [2,3,5,4,1,7].

Пример 2:

Input: nums = [1,2,3,4,4,3,2,1], n = 4

Output: [1,4,2,3,3,2,4,1]

Пример 3:

Input: nums = [1,1,2,2], n = 2

Output: [1,2,1,2]

Ограничения:

1 <= n <= 500

nums.length == 2n

1 <= nums[i] <= 10^3

```go
func shuffle(nums []int, n int) []int {

}
```


<https://leetcode.com/problems/shuffle-the-array/>

## 11. Текущее значение суммы в одномерном массиве
Дан массив nums. Мы определяем текущее значение суммы массива как runningSum[i] = sum(nums [0]…nums [i]).

Верните текущее значение суммы nums.

Пример 1:

Input: nums = [1,2,3,4]

Output: [1,3,6,10]

Объяснение: Текущее значение суммы получается следующим образом: [1, 1+2, 1+2+3, 1+2+3+4].

Пример 2:

Input: nums = [1,1,1,1,1]

Output: [1,2,3,4,5]

Объяснение: Текущее значение суммы получается следующим образом: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].

Пример 3:

Input: nums = [3,1,2,10,1]

Output: [3,4,6,16,17]

Ограничения:

1 <= nums.length <= 1000

-10^6 <= nums [i] <= 10^6

```go
func runningSum(nums []int) []int {

}
```

<https://leetcode.com/problems/running-sum-of-1d-array/>

## 12. Количество хороших пар
Дан массив целых чисел nums. Верните количество хороших пар.

Пара (i, j) называется хорошей, если nums [i] == nums [j] и i <j.

Пример 1:

Input: nums = [1,2,3,1,1,3]

Output: 4

Объяснение: Есть 4 хорошие пары (0,3), (0,4), (3,4), (2,5), с нулевым индексом.

Пример 2:

Input: nums = [1,1,1,1]

Output: 6

Объяснение: Каждая пара в массиве является хорошей.

Пример 3:

Input: nums = [1,2,3]

Output: 0

Ограничения:

1 <= nums.length <= 100

1 <= nums [i] <= 100

```go
func numIdenticalPairs(nums []int) int {

}
```

<https://leetcode.com/problems/number-of-good-pairs/>

## 13. Драгоценности и камни
Вам даны строки jewels, представляющие типы камней, которые являются драгоценностями, и камни, представляющие stones, которые у вас есть. Каждый символ в stones является типом камня, который у вас есть. Вы хотите знать, сколько из камней, которые у вас есть, также являются драгоценностями.

Буквы чувствительны к регистру, поэтому «a» считается разным типом камня от «A».

Пример 1:

Input: jewels = "aA", stones = "aAAbbbb"

Output: 3

Пример 2:

Input: jewels = "z", stones = "ZZ"

Output: 0

Ограничения:

1 <= jewels.length, stones.length <= 50

jewels и stones состоят только из английских букв.

Все символы jewels уникальны.

```go
func numJewelsInStones(jewels string, stones string) int {

}
```

<https://leetcode.com/problems/jewels-and-stones/>

## 14. Богатство самого богатого клиента
Вам дана матрица целых чисел accounts, где accounts[i][j] - это сумма денег, которые имеет i-й клиент в j-м банке. Верните богатство самого богатого клиента.

Богатство клиента - это сумма денег, которые он имеет во всех своих банковских счетах. Самым богатым клиентом считается клиент с максимальным богатством.

Пример 1:

Input: accounts = [[1,2,3],[3,2,1]]

Output: 6

Объяснение:

1-й клиент имеет богатство = 1 + 2 + 3 = 6

2-й клиент имеет богатство = 3 + 2 + 1 = 6

Оба клиента считаются самыми богатыми с богатством 6 каждый, поэтому возвращаем 6.

Пример 2:

Input: accounts = [[1,5],[7,3],[3,5]]

Output: 10

Объяснение:

1-й клиент имеет богатство = 6

2-й клиент имеет богатство = 10

3-й клиент имеет богатство = 8

2-й клиент является самым богатым с богатством 10.

Пример 3:

Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]

Output: 17

Ограничения:

m == accounts.length

n == accounts[i].length

1 <= m, n <= 50

1 <= accounts[i][j] <= 100

```go
func maximumWealth(accounts [][]int) int {

}
```

<https://leetcode.com/problems/richest-customer-wealth/>

## 15. Дизайн парковочной системы
Спроектировать парковочную систему для парковки. На парковке есть три вида парковочных мест: большие, средние и маленькие, с фиксированным количеством мест для каждого размера.

Реализуйте класс ParkingSystem:

ParkingSystem(int big, int medium, int small) Инициализирует объект класса ParkingSystem. Количество мест для каждого парковочного места указано в конструкторе.

bool addCar(int carType) Проверяет, есть ли парковочное место типа carType для автомобиля, который хочет попасть на стоянку. carType может быть трех видов: большой, средний или маленький, которые представлены цифрами 1, 2 и 3 соответственно. **Автомобиль может парковаться только на парковочном месте своего** типа автомобиля carType. Если места нет, верните false, в противном случае припаркуйте машину на месте такого размера и верните true.

Пример 1:

Input

["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]

[[1, 1, 0], [1], [2], [3], [1]]

Output

[null, true, true, false, false]

Объяснение

ParkingSystemparkingSystem = новая ParkingSystem(1, 1, 0);

parkingSystem.addCar(1); // возвращаем true, потому что есть 1 свободный слот для большой машины

parkingSystem.addCar(2); // вернем true, потому что есть 1 свободный слот для средней машины

parkingSystem.addCar(3); // вернем false, потому что нет свободного слота для маленькой машины

parkingSystem.addCar(1); // вернем false, потому что нет свободного места для большой машины. Оно уже занято.

Ограничения:

0 <= большой, средний, маленький <= 1000

carType — 1, 2 или 3.

В addCar будет сделано не более 1000 запросов.

```go
type ParkingSystem struct {



}

func Constructor(big int, medium int, small int) ParkingSystem {



}

func (this \*ParkingSystem) AddCar(carType int) bool {



}
```

<https://leetcode.com/problems/design-parking-system/>

## 16. Наименьшее четное кратное
Дано **положительное** целое число n. Верните наименьшее положительное целое число, которое является кратным **как** 2, **так** и n.

Пример 1:

Input: n = 5

Output: 10

Объяснение: Наименьшим кратным числом для 5 и 2 является 10.

Пример 2:

Input: n = 6

Output: 6

Объяснение: Наименьшим кратным числом для 6 и 2 является 6. Обратите внимание, что число является кратным само себе.

Ограничения:

1 <= n <= 150

```go
func smallestEvenMultiple(n int) int {

}
```

<https://leetcode.com/problems/smallest-even-multiple/>

## 17. Максимальное количество найденных слов в предложениях
«Предложение» — это список слов, разделенных одним пробелом, без ведущих или завершающих пробелов.

Вам дается массив строк sentences, где sentences[i] представляет одно предложение.

Верните максимальное количество слов, которые появляются в одном предложении.

Пример 1:

Input: sentences = ["alice and bob love leetcode", "i think so too", "this is great thanks very much"]

Output: 6

Объяснение:

Первое предложение, "alice and bob love leetcode", всего имеет 5 слов.

Второе предложение, "i think so too", всего имеет 4 слова.

Третье предложение, "this is great thanks very much", всего имеет 6 слов.

Таким образом, максимальное количество слов в одном предложении есть в третьем предложении, которое имеет 6 слов.

Пример 2:

Input: sentences = ["please wait", "continue to fight", "continue to win"]

Output: 3

Объяснение: Возможно, несколько предложений содержат одинаковое количество слов.

В этом примере второе и третье предложение (подчеркнутые) имеют одинаковое количество слов.

Ограничения:

1 <= sentences.length <= 100

1 <= sentences[i].length <= 100

sentences[i] состоит только из строчных английских букв и только ' '.

sentences[i] не имеет ведущих или завершающих пробелов.

Все слова в sentences[i] разделены одинарным пробелом.

```go
func mostWordsFound(sentences []string) int {

}
```

<https://leetcode.com/problems/maximum-number-of-words-found-in-sentences/>

## 18. Разница между суммой элементов и суммой цифр массива
Дан массив положительных целых чисел nums.

- Сумма элементов - это сумма всех элементов в nums.
- Сумма цифр - это сумма всех цифр (не обязательно уникальных) которые появляются в nums.

Верните абсолютную разницу между суммой элементов и суммой цифр nums.

Обратите внимание, что абсолютная разница между двумя целыми числами x и y определяется как |x - y|.

Пример 1:

Input: nums = [1,15,6,3]

Output: 9

Объяснение:

Cумма элементов nums равна 1 + 15 + 6 + 3 = 25.

Cумма цифр nums равна 1 + 1 + 5 + 6 + 3 = 16.

Абсолютная разница между суммой элементов и суммой цифр равна |25 - 16| = 9.

Пример 2:

Input: nums = [1, 2, 3, 4]

Output: 0

Объяснение:

Сумма элементов nums равна 1 + 2 + 3 + 4 = 10.

Сумма цифр nums равна 1 + 2 + 3 + 4 = 10.

Абсолютная разница между суммой элементов и суммой цифр равна |10 - 10| = 0.

Ограничения:

1 <= nums.length <= 2000

1 <= nums[i] <= 2000

```go
func differenceOfSum(nums []int) int {

}
```

<https://leetcode.com/problems/difference-between-element-sum-and-digit-sum-of-an-array/>

## 19. Минимальная сумма четырехзначного числа после разделения цифр
Дано положительное четырехзначное число num. Разделите num на два новых числа new1 и new2, используя цифры, найденные в num. В new1 и new2 разрешены ведущие нули, и все цифры, найденные в num, должны быть использованы.

Например, дано num = 2932, у вас есть следующие цифры: две 2, одна 9 и одна 3. Некоторые из возможных пар [new1, new2] это [22, 93], [23, 92], [223, 9] и [2, 329].

Вернуть минимально возможную сумму new1 и new2.

Пример 1:

Input: num = 2932

Output: 52

Объяснение: Некоторые возможные пары [new1, new2] - [29, 23], [223, 9] и т.д. Минимальная сумма может быть получена парой [29, 23]: 29 + 23 = 52.

Пример 2:

Input: num = 4009

Output: 13

Объяснение: Некоторые возможные пары [new1, new2] - [0, 49], [490, 0] и т.д.

Минимальная сумма может быть получена парой [4, 9]: 4 + 9 = 13.

Ограничения:

1000 <= num <= 9999

```go
func minimumSum(num int) int {

}
```

<https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/>

## 20. Дети с наибольшим количеством конфет
У вас есть n детей с конфетами. Вам дан целочисленный массив candies, где candies [i] представляет количество конфет, которые имеет n-й ребенок, и целое число extraCandies, указывающее количество дополнительных конфет, которые у вас есть.

Верните логический массив result длиной n, где result [i] равен true, если, после того, как вы дадите n-му ребенку все extraCandies, они будут иметь наибольшее количество конфет среди всех детей, или false в противном случае.

Обратите внимание, что у нескольких детей может быть наибольшее количество конфет.

Пример 1:

Input: candies = [2,3,5,1,3], extraCandies = 3

Output: [true,true,true,false,true]

Объяснение: Если вы дадите все extraCandies:

\- Ребенок 1 будет иметь 2 + 3 = 5 конфет, что является наибольшим среди детей.

\- Ребенок 2 будет иметь 3 + 3 = 6 конфет, что является наибольшим среди детей.

\- Ребенок 3 будет иметь 5 + 3 = 8 конфет, что является наибольшим среди детей.

\- Ребенок 4 будет иметь 1 + 3 = 4 конфеты, что не является наибольшим среди детей.

\- Ребенок 5 будет иметь 3 + 3 = 6 конфет, что является наибольшим среди детей.

Пример 2:

Input: candies = [4,2,1,1,2], extraCandies = 1

Output: [true,false,false,false,false]

Объяснение: Есть только 1 дополнительная конфета.

Ребенок 1 всегда будет иметь наибольшее количество конфет, даже если другой ребенок получит дополнительную конфету.

Пример 3:

Input: candies = [12,1,12], extraCandies = 10

Output: [true,false,true]

Ограничения:

n == candies.length

2 <= n <= 100

1 <= candies[i] <= 100

1 <= extraCandies <= 50

```go
func kidsWithCandies(candies []int, extraCandies int) []bool {

}
```

<https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/>

## 21. Разница между произведением и суммой цифр целого числа
Дано целое число n. Верните разницу между произведением его цифр и суммой его цифр.

Пример 1:

Input: n = 234

Output: 15

Объяснение:

Произведение цифр = 2 \* 3 \* 4 = 24

Сумма цифр = 2 + 3 + 4 = 9

Результат = 24 - 9 = 15

Пример 2:

Input: n = 4421

Output: 21

Объяснение:

Произведение цифр = 4 \* 4 \* 2 \* 1 = 32

Сумма цифр = 4 + 4 + 2 + 1 = 11

Результат = 32 - 11 = 21

Ограничения:

1 <= n <= 10^5

```go
func subtractProductAndSum(n int) int {

}
```

<https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/>

## 22. Сколько чисел меньше, чем текущее число
Дан массив nums. Для каждого nums [i] выясните, сколько чисел в массиве меньше его. То есть, для каждого nums [i] вам нужно посчитать количество допустимых j, таких что j != i и nums [j] <nums [i].

Верните ответ в виде массива.

Пример 1:

Input: nums = [8,1,2,2,3]

Output: [4,0,1,1,3]

Объяснение:

Для nums [0] = 8 существует четыре меньших числа, чем оно (1, 2, 2 и 3).

Для nums [1] = 1 не существует меньшего числа, чем оно.

Для nums [2] = 2 существует одно меньшее число, чем оно (1).

Для nums [3] = 2 существует одно меньшее число, чем оно (1).

Для nums [4] = 3 существует три меньших числа, чем оно (1, 2 и 2).

Пример 2:

Input: nums = [6,5,4,8]

Output: [2,1,0,3]

Пример 3:

Input: nums = [7,7,7,7]

Output: [0,0,0,0]

Ограничения:

2 <= nums.length <= 500

0 <= nums [i] <= 100

```go
func smallerNumbersThanCurrent(nums []int) []int {

}
```

<https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/>

## 23. Интерпретация синтаксического анализатора цели
У вас есть синтаксический анализатор целей, который может интерпретировать строковую команду. Команда состоит из алфавита "G", "()" и/или "(al)" в некотором порядке. Анализатор целей будет интерпретировать "G" как строку "G", "()" как строку "o" и "(al)" как строку "al". Затем интерпретируемые строки объединяются в исходном порядке.

Учитывая строковую команду, вернуть интерпретацию команды синтаксического анализатора целей.

Пример 1:

Input: command = "G()(al)"

Output: "Goal"

Объяснение: Синтаксический анализатор целей интерпретирует команду следующим образом:

G -> G

() -> o

(al) -> al

Конечным объединенным результатом является "Goal".

Пример 2:

Input: command = "G()()()()(al)"

Output: "Gooooal"

Example 3:

Input: command = "(al)G(al)()()G"

Output: "alGalooG"

Ограничения:

1 <= command.length <= 100

command состоит из "G", "()", и/или "(al)" в некотором порядке.

```go
func interpret(command string) string {

}
```

<https://leetcode.com/problems/goal-parser-interpretation/>

## 24. Декодирование XOR-массива
Есть скрытый массив целых чисел arr, состоящий из n неотрицательных целых чисел.

Он был закодирован в другой массив encoded длиной n - 1, так что encoded [i] = arr [i] XOR arr [i + 1]. Например, если arr = [1,0,2,1], то encoded = [1,2,3].

Вам дан закодированный массив. Вам также дано целое число first, это первый элемент arr, т.е. arr [0].

Верните исходный массив arr. Может быть доказано, что ответ существует и является уникальным.

Пример 1:

Input: encoded = [1,2,3], first = 1

Output: [1,0,2,1]

Объяснение: Если arr = [1,0,2,1], то first = 1 и encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]

Пример 2:

Input: encoded = [6,2,7,3], first = 4

Output: [4,2,0,7,4]

Ограничения:

2 <= n <= 104

encoded.length == n - 1

0 <= encoded[i] <= 105

0 <= first <= 105

```go
func decode(encoded []int, first int) []int {

}
```

<https://leetcode.com/problems/decode-xored-array/>
## 25. Создать целевой массив в заданном порядке
Даны два массива целых чисел nums и index. Ваша задача создать целевой массив следующим образом:

Изначально целевой массив пуст. Слева направо читайте nums[i] и index[i], вставляйте значение nums[i] в целевой массив в позицию index[i]. Повторяйте предыдущий шаг, пока не закончатся элементы в nums и index. Верните целевой массив.

Гарантируется, что операции вставки будут допустимыми.

Пример 1:

Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]

Output: [0,4,1,3,2]

Объяснение:

nums       index     target

0            0             [0]

1            1             [0,1]

2            2             [0,1,2]

3            2             [0,1,3,2]

4            1             [0,4,1,3,2]

Пример 2:

Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]

Output: [0,1,2,3,4]

Объяснение:

nums       index     target

1            0             [1]

2            1             [1,2]

3            2             [1,2,3]

4            3             [1,2,3,4]

0            0             [0,1,2,3,4]

Пример 3:

Input: nums = [1], index = [0]

Output: [1]

Ограничения:

1 <= nums.length, index.length <= 100

nums.length == index.length

0 <= nums[i] <= 100

0 <= index[i] <= i

```go
func createTargetArray(nums []int, index []int) []int {

}
```

<https://leetcode.com/problems/create-target-array-in-the-given-order/>

## 26. Распаковать список сжатых файлов
Дан сжатый список nums целых чисел, представляющих список, сжатый с помощью RLE кодированием.

Рассмотрите каждую соседнюю пару элементов [freq, val] = [nums [2 \* i], nums [2 \* i + 1]] (с i >= 0). Для каждой такой пары есть freq элементы со значением val, соединенных в подсписок. Соедините все подсписки слева направо, чтобы сгенерировать распакованный список.

Верните распакованный список.

Пример 1:

Input: nums = [1,2,3,4]

Output: [2,4,4,4]

Объяснение: Первая пара [1,2] означает, что у нас есть freq = 1 и val = 2, поэтому мы генерируем массив [2].

Вторая пара [3,4] означает, что у нас есть freq = 3 и val = 4, поэтому мы генерируем [4,4,4].

В конечном итоге связывание [2] + [4,4,4] является [2,4,4,4].

Пример 2:

Input: nums = [1,1,2,3]

Output: [1,3,3]

Ограничения:

2 <= nums.length <= 100

nums.length % 2 == 0

1 <= nums[i] <= 100

```go
func decompressRLElist(nums []int) []int {

}
```

<https://leetcode.com/problems/decompress-run-length-encoded-list/>

## 27. Разделить строку на сбалансированные строки
Сбалансированные строки — это те, которые имеют равное количество символов “L“ и “R“.

Учитывая сбалансированную строку s, разделите ее на некоторое количество подстрок так, чтобы:

Каждая подстрока сбалансирована.

Верните максимальное количество сбалансированных строк, которое вы можете получить.

Пример 1:

Input: s = "RLRRLLRLRL"

Output: 4

Объяснение: s можно разделить на "RL", "RRLL", "RL", "RL", каждая подстрока содержит одинаковое количество 'L' и 'R'.

Пример 2:

Input: s = "RLRRRLLRLL"

Output: 2

Объяснение: s можно разделить на "RL", "RRRLLRLL", каждая подстрока содержит одинаковое количество 'L' and 'R'.

Обратите внимание, что s нельзя разделить на "RL", "RR", "RL", "LR", "LL", потому что 2-я и 5-я подстроки не сбалансированы.

Пример 3:

Input: s = "LLLLRRRR"

Output: 1

Объяснение: s можно разделить на "LLLLRRRR".

Ограничения:

2 <= s.length <= 1000

s[i] это либо 'L' или 'R'.

s – сбалансированная строка.

```go
func balancedStringSplit(s string) int {

}
```

<https://leetcode.com/problems/split-a-string-in-balanced-strings/>
## 28. Подсчитайте цифры, которые делят число
Дано целое число, вернуть количество цифр в числе, которые делят число.

Целое число val делит nums, если nums % val == 0.

Пример 1:

Input: num = 7

Output: 1

Объяснение: 7 делится само на себя, следовательно, ответ равен 1.

Пример 2:

Input: num = 121

Output: 2

Объяснение: 121 делится на 1, но не на 2. Поскольку 1 встречается дважды как цифра, мы возвращаем 2.

Пример 3:

Input: num = 1248

Output: 4

Объяснение: 1248 делится на все свои цифры, поэтому ответ равен 4.

Ограничения:

1 <= num <= 109

num не содержит 0 в качестве одной из своих цифр.

```go
func countDigits(num int) int {

}
```

<https://leetcode.com/problems/count-the-digits-that-divide-a-number/>

## 29. Операция XOR в массиве
Вам дано целое число n и целое число start.

Определите массив nums, где nums[i] = start + 2 \* i (0-индексированный) и n == nums.length.

Верните побитовое XOR всех элементов nums.

Пример 1:

Input: n = 5, start = 0

Output: 8

Объяснение: Массив nums равен [0, 2, 4, 6, 8], где (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.

Где "^" соответствует побитовому оператору XOR.

Пример 2:

Input: n = 4, start = 3

Output: 8

Объяснение: Массив nums равен [3, 5, 7, 9], где (3 ^ 5 ^ 7 ^ 9) = 8

Ограничения:

1 <= n <= 1000

0 <= start <= 1000

n == nums.length

```go
func xorOperation(n int, start int) int {

}
```

<https://leetcode.com/problems/xor-operation-in-an-array/>
## 30. Посчитать хорошие тройки
Дан массив целых чисел arr и три целых числа a, b и c. Вам нужно найти количество хороших троек.

Тройка (arr [i], arr [j], arr [k]) хороша, если следующие условия верны:

- 0 <= i < j < k < arr.length
- |arr[i] - arr[j]| <= a
- |arr[j] - arr[k]| <= b
- |arr[i] - arr[k]| <= c

Где |х| обозначает модуль х.

Верните количество хороших троек.

Пример 1:

Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3

Output: 4

Объяснение: Есть 4 хорошие тройки: [(3,0,1), (3,0,1), (3,1,1),

Пример 2:

Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1

Output: 0

Объяснение: Ни одна тройка не удовлетворяет всем условиям.

Constraints:

- 3 <= arr.length <= 100
- 0 <= arr[i] <= 1000
- 0 <= a, b, c <= 1000

<https://leetcode.com/problems/count-good-triplets/>

## 31. Отсортировать людей
Вам дан массив строк имен и массив высот, состоящий из уникальных положительных целых чисел. Оба массива имеют длину n.

Для каждого индекса i имена [i] и высота [i] обозначают имя и высоту i-го человека.

Верните имена, отсортированные в порядке убывания по высоте людей.

Пример 1:

Input: names = ["Mary","John","Emma"], heights = [180,165,170]

Output: ["Mary","Emma","John"]

Объяснение: Мэри самая высокая, за ней Эмма и Джон..

Пример 2:

Input: names = ["Alice","Bob","Bob"], heights = [155,185,150]

Output: ["Bob","Alice","Bob"]

Объяснение: Первый Боб самый высокий, за ним Алиса и второй Боб..



Constraints:

- n == names.length == heights.length
- 1 <= n <= 103
- 1 <= names[i].length <= 20
- 1 <= heights[i] <= 105
- names[i] состоит из букв английского алфавита в верхнем и нижнем регистре.
- Все значения высот являются уникальными.

<https://leetcode.com/problems/sort-the-people/>

# Задачи уровня Medium
## 1. Сумма самых глубоких листьев.
Дан root дерево бинарных данных, верните сумму значений его самых глубоких листьев.

Пример 1:


Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]

Output: 15

Пример 2:

Input: root = [,,8,,,,9,null,,,null,null,null,]

Output: 19

Constraints:

- Количество узлов в дереве находится в диапазоне [1, 104].
- 1 <= Node.val <= 100

<https://leetcode.com/problems/deepest-leaves-sum/>
## 2. Отсортируйте студентов по их K-му баллу.
Дана класс с m студентами и n экзаменами. Вам дана матрица целых чисел 0-индексированных m x n, где каждая строка представляет одного студента, а score [i] [j] обозначает балл, который i-тый студент получил на j-том экзамене. Матрица оценок содержит только уникальные целые числа.

Вам также дано целое число k. Отсортируйте студентов (т. e. Строки матрицы) по их баллам в k-ом (0-индексированном) экзамене от высшего к низшему.

Верните матрицу после сортировки.

Пример 1:

Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2

Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]

Объяснение: На диаграмме выше S обозначает студента, а E - экзамен.

\- Студент с индексом 1 получил 11 баллов в экзамене 2, что является самым высоким результатом, поэтому он занял первое место.

\- Студент с индексом 0 получил 9 баллов в экзамене 2, что является вторым по высоте результатом, поэтому он занял второе место.

\- Студент с индексом 2 получил 3 балла в экзамене 2, что является самым низким результатом, поэтому он занял третье место.

Пример 2:

Input: score = [[3,4],[5,6]], k = 0

Output: [[5,6],[3,4]]

Объяснение: На диаграмме выше S обозначает студента, а E - экзамен.

\- Студент с индексом 1 получил 5 баллов в экзамене 0, что является самым высоким результатом, поэтому он занял первое место.

\- Студент с индексом 0 получил 3 балла в экзамене 0, что является самым низким результатом, поэтому он занял второе место.

Constraints:

- m == score.length
- n == score[i].length
- 1 <= m, n <= 250
- 1 <= score[i][j] <= 105
- score consists of distinct integers.
- 0 <= k < n

<https://leetcode.com/problems/sort-the-students-by-their-kth-score/>
## 3. Объединить узлы
Вам дан заголовок связанного списка, который содержит ряд целых чисел, разделенных нулями. Начало и конец связного списка будет иметь Node.val == 0.

Для каждых двух последовательных нулей объединяйте все узлы, лежащие между ними в один узел, чье значение является суммой всех объеденных узлов. Измененный список не должен содержать никаких нулей.

Верните заголовок измененного связного списка.

Пример 1:

Input: head = [0,3,1,0,4,5,2,0]

Output: [4,11]

Объяснение: Вышеуказанная фигура представляет собой связанный список. Измененный список содержит:

\- Сумму узлов, помеченных зеленым: 3 + 1 = 4.

\- Сумму узлов, помеченных красным: 4 + 5 + 2 = 11.

Пример 2:

Input: head = [0,1,0,3,0,2,2,0]

Output: [1,3,4]

Объяснение:

Вышеуказанная фигура представляет собой данный связанный список. Измененный список содержит:

\- Сумму узлов, отмеченных зеленым цветом: 1 = 1.

\- Сумму узлов, отмеченных красным цветом: 3 = 3.

\- Сумму узлов, отмеченных желтым цветом: 2 + 2 = 4.

Constraints:

- Количество узлов в списке находится в диапазоне [3, 2 \* 105].
- 0 <= Node.val <= 1000
- Нет двух последовательных узлов с Node.val == 0.
- Начало и конец связного списка имеют Node.val == 0.

<https://leetcode.com/problems/merge-nodes-in-between-zeros/>
## 4. Бинарное дерево в большую сумму дерева.
Дано root звено бинарного поискового дерева (BST), преобразуйте его в большее дерево так, чтобы каждый ключ исходного BST был изменен на исходный ключ плюс сумма всех ключей, больших исходного ключа в BST.

В качестве напоминания, бинарное поисковое дерево - это дерево, которое удовлетворяет следующим ограничениям:

- Левое поддерево узла содержит только узлы с ключами меньше ключа узла.
- Правое поддерево узла содержит только узлы с ключами больше ключа узла.
- Оба поддерева должны быть также бинарными поисковыми деревьями.

Пример 1:

Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]

Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

Пример 2:

Input: root = [0,null,1]

Output: [1,null,1]

Constraints:

- Диапазон значений узлов находится в диапазоне [1, 100]
- 0 <= Node.val <= 100
- Все значения в дереве уникальны.

<https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/>

## 5. Максимальная сумма двух звеньев связанного списка
В связанном списке размера n, где n является четным,  i-й узел (с 0 индексом) связанного списка известен как близнец(twin) (n-1-i) узла, если 0 <= i <= (n / 2) - 1.

- Например, если n = 4, то узел 0 является близнецом узла 3, а узел 1 является близнецом узла 2. Это единственные узлы с близнецами для n = 4.

Сумма близнецов(twin sum) определяется как сумма узла и его близнеца.

Дан заголовок связанного списка с четной длиной, верните максимальную сумму близнецов связанного списка.

Пример 1:

Input: head = [5,4,2,1]

Output: 6

Объяснение:

Узлы 0 и 1 являются близнецами узлов 3 и 2 соответственно. Все имеют сумму близнецов = 6. В связанном списке нет других узлов с близнецами. Таким образом, максимальная сумма близнецов в связанном списке составляет 6.

Пример 2:


Input: head = [4,2,2,3]

Output: 7

Объяснение:

Узлы с двойниками в этом связанном списке:

\- Узел 0 является двойником узла 3 с двойной суммой 4 + 3 = 7.

\- Узел 1 является двойником узла 2 с двойной суммой 2 + 2 = 4.

Таким образом, максимальная двойная сумма связанного списка равна max(7, 4) = 7.

Пример 3:

Input: head = [1,100000]

Output: 100001

Объяснение:

В связанном списке с двойным суммой 1 + 100000 = 100001 есть только один узел с двойником.

Constraints:

- Число узлов в списке является четным целым числом в диапазоне [2, 105].
- 1 <= Node.val <= 105

<https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/>

## 6. Максимальное бинарное дерево
Вам дан массив целых чисел nums без дубликатов. Максимальное бинарное дерево может быть построено рекурсивно из nums с помощью следующего алгоритма:

Создайте корневой узел, значение которого является максимальным значением в nums.

Рекурсивно постройте левое поддерево на подмассиве префикса левее максимального значения.

Рекурсивно постройте правое поддерево на подмассиве суффикса правее максимального значения.

Верните максимальное бинарное дерево, построенное из nums.

Пример 1:

Input: nums = [3,2,1,6,0,5]

Output: [6,3,5,null,2,0,null,null,1]

Объяснение: Рекурсивные вызовы выглядят следующим образом:

\- Наибольшее значение в [3,2,1,6,0,5] является 6. Левый префикс равен [3,2,1] и правый суффикс равен [0,5].

\- Наибольшее значение в [3,2,1] является 3. Левый префикс равен [] и правый суффикс равен [2,1].

\- Пустой массив, поэтому нет детей.

\- Наибольшее значение в [2,1] является 2. Левый префикс равен [] и правый суффикс равен [1].

\- Пустой массив, поэтому нет детей.

\- Только один элемент, поэтому ребенок - узел со значением 1.

\- Наибольшее значение в [0,5] является 5. Левый префикс равен [0] и правый суффикс равен [].

\- Только один элемент, поэтому ребенок - узел со значением 0.

\- Пустой массив, поэтому нет детей.

Пример  2:

Input: nums = [3,2,1]

Output: [3,null,2,null,1]

Constraints:

- 1 <= nums.length <= 1000
- 0 <= nums[i] <= 1000
- All integers in nums are unique.

<https://leetcode.com/problems/maximum-binary-tree/>

## 7. Балансировка бинарного поискового дерева
Дано корневое значение бинарного поискового дерева. Верните сбалансированное бинарное поисковое дерево с теми же значениями узлов. Если есть более одного ответа, верните любой из них.

Бинарное поисковое дерево считается сбалансированным, если глубина двух поддеревьев каждого узла никогда не отличается более чем на 1.

Пример 1:

Input: root = [1,null,2,null,3,null,4,null,null]

Output: [2,1,3,null,null,null,4]

Explanation: Это не единственный правильный ответ, [3,1,4,null,2] также правильный.

Пример 2:

Input: root = [2,1,3]

Output: [2,1,3]

Constraints:

- Количество узлов в дереве находится в диапазоне [1, 104].
- 1 <= Node.val <= 105

<https://leetcode.com/problems/balance-a-binary-search-tree/>

## 8. Минимальное количество вершин для достижения всех узлов
Дан ориентированный ациклический граф, с n вершинами, пронумерованными от 0 до n-1, и массив ребер, где edges [i] = [fromi, toi] представляет собой направленное ребро от узла fromi к узлу toi .

Найдите самый маленький набор вершин, из которых достижимы все узлы в графе. Гарантируется существование уникального решения.

Обратите внимание, что вы можете вернуть вершины в любом порядке.

Пример 1:

Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]

Output: [0,3]

Объяснение: Невозможно достичь всех узлов из одной вершины. От 0 мы можем достичь [0,1,2,5]. От 3 мы можем достичь [3,4,2,5]. Так что мы выводим [0,3].].

Пример 2:

Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]

Output: [0,2,3]

Объяснение: Обратите внимание, что вершины 0, 3 и 2 недостижимы из любой другой вершины, поэтому мы должны их включить. Также любая из этих вершин может достичь узлов 1 и 4.



Constraints:

- 2 <= n <= 10^5
- 1 <= edges.length <= min(10^5, n \* (n - 1) / 2)
- edges[i].length == 2
- 0 <= fromi, toi < n
- All pairs (fromi, toi) are distinct.

<https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/>

## 9. Арифметические подмассивы
Последовательность чисел называется арифметической, если она состоит как минимум из двух элементов, а разница между каждыми двумя соседними элементами одинакова. Более формально, последовательность s является арифметической, если и только если s[i + 1] - s[i] == s[1] - s[0] для всех допустимых i.

Например, это арифметические последовательности:

Следующая последовательность не является арифметической:

Вам дан массив из n целых чисел, nums и два массива из m целых чисел каждый, l и r, представляющий m диапазонов запросов, где i-й запрос является диапазоном [l [i], r [i]]. Все массивы имеют индекс 0.

Верните список булевых элементов ответа, где answer [i] является true, если подмассив nums [l [i]], nums [l [i] + 1], ..., nums [r [i]] можно переупорядочить для формирования арифметической последовательности, и false в противном случае.

Пример 1:

Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]

Output: [true,false,true]

Объяснение:

В 0-м запросе подмассив состоит из [4,6,5]. Это можно переставить как [6,5,4], что является арифметической прогрессией.

В 1-м запросе подмассив состоит из [4,6,5,9]. Это не может быть переставлено в арифметическую прогрессию.

Во 2-м запросе подмассив состоит из [5,9,3,7]. Это может быть переставлено как [3,5,7,9], что является арифметической прогрессией.Arithmetic Subarrays

Пример 2:

Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]

Output: [false,true,false,false,true,true]

Constraints:

- n == nums.length
- m == l.length
- m == r.length
- 2 <= n <= 500
- 1 <= m <= 500
- 0 <= l[i] < r[i] < n
- -105 <= nums[i] <= 105

<https://leetcode.com/problems/arithmetic-subarrays/>

## 10. Возможности буквенных плиток.
У вас есть n плиток, на каждой из которых напечатана одна буква tiles[i].

Верните количество возможных непустых последовательностей букв, которые вы можете составить, используя буквы, напечатанные на этих плитках.

Пример 1:

Input: tiles = "AAB"

Output: 8

Объяснение : Возможные последовательности: "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA".

Пример 2:

Input: tiles = "AAABBC"

Output: 188

Пример 3:

Input: tiles = "V"

Output: 1

Constraints:

- 1 <= tiles.length <= 7
- Набор плиток состоит из заглавных букв английского алфавита..

<https://leetcode.com/problems/letter-tile-possibilities/>

## 11. Удалить листья с заданным значением
Дано root дерево бинарных данных и целочисленное значение target. Удалите все листовые узлы со значением target.

Обратите внимание, что после удаления листового узла со значением target его родительский узел становится листовым узлом со значением target и также должен быть удален (необходимо продолжать делать это, пока это будет невозможным).

Пример 1:

Input: root = [1,2,3,2,null,2,4], target = 2

Output: [1,null,3,null,4]

Объяснение: Листовые узлы зеленого цвета со значением (target= 2) удалены (изображение слева).

После удаления новые узлы становятся листовыми узлами со значением (target= 2) (изображение в центре).

Пример 2:

Input: root = [1,3,3,3,2], target = 3

Output: [1,3,null,null,2]

Пример 3:

Input: root = [1,2,null,2,null,2], target = 2

Output: [1]

Объяснение: Листовые узлы в зеленом со значением (target = 2) удаляются на каждом шаге.

Constraints:

- Количество узлов в дереве находится в диапазоне [1, 3000].
- 1 <= Node.val, target <= 1000

<https://leetcode.com/problems/delete-leaves-with-a-given-value/>

## 12. Объединить между связанными списками
Вам даны два связанных списка: list1 и list2 по размерам n и m соответственно. Удалите узлы списка 1 с ath узла до bth узла и поместите list2 на их место. Синие ребра и узлы на рисунке ниже показывают результат:

Собрать список результатов и вернуть его заголовок.

Пример 1:



Input: list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]

Output: [0,1,2,1000000,1000001,1000002,5]

Объяснение: Мы удаляем узлы 3 и 4 и помещаем весь list2 на их место. Синие края и узлы на рисунке выше показывают результат.

Пример 2:

Input: list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]

Output: [0,1,1000000,1000001,1000002,1000003,1000004,6]

Объяснение: Синие рёбра и узлы на рисунке выше обозначают результат.

Constraints:

- 3 <= list1.length <= 104
- 1 <= a <= b < list1.length - 1
- 1 <= list2.length <= 104

<https://leetcode.com/problems/merge-in-between-linked-lists/>

## 13. Найти максимальную сумму песочных часов
Вам дана целочисленная матрица m x n.

Мы определяем песочные часы как часть матрицы со следующей формой:

Вернуть максимальную сумму элементов песочных часов.

Обратите внимание, что песочные часы не могут быть повернуты и должны быть полностью содержаться в матрице.

` `Пример 1:

Input: grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]

Output: 30

Объяснение: Ячейки, показанные выше, представляют часы с максимальной суммой: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.

Пример 2:

Input: grid = [[1,2,3],[4,5,6],[7,8,9]]

Output: 35

Объяснение: В матрице есть только одна фигура песочных часов, сумма которой составляет: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.

Constraints:

- m == grid.length
- n == grid[i].length
- 3 <= m, n <= 150
- 0 <= grid[i][j] <= 106

<https://leetcode.com/problems/maximum-sum-of-an-hourglass/>

## 14. Запросы XOR подмассива
Вам дан массив arr положительных целых чисел. Вам также дан массив запросов, где queries [i] = [lefti, righti].

Для каждого запроса i вычислите XOR элементов от lefti до righti (то есть, arr [lefti] XOR arr [lefti + 1] XOR ... XOR arr [righti]).

Верните массив ответов, где answer [i] является ответом на ith-запрос.

Пример 1:

Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]

Output: [2,7,14,8]

Объяснение:

Бинарное представление элементов массива:

1 = 0001

3 = 0011

4 = 0100

8 = 1000

Значения XOR для запросов:

[0,1] = 1 xor 3 = 2

[1,2] = 3 xor 4 = 7

[0,3] = 1 xor 3 xor 4 xor 8 = 14

[3,3] = 8

Example 2:

Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]

Output: [8,0,4,4]

Constraints:

- 1 <= arr.length, queries.length <= 3 \* 104
- 1 <= arr[i] <= 109
- queries[i].length == 2
- 0 <= lefti <= righti < arr.length

<https://leetcode.com/problems/xor-queries-of-a-subarray/>

## 15. Разбиение на минимальное количество децимальных двоичных чисел
Десятичное число называется деци-двоичным, если каждая из его цифр либо 0, либо 1, без ведущих нулей. Например, 101 и 1100 являются деци-двоичными, в то время как 112 и 3001 нет.

Дана строка n, представляющая собой положительное десятичное целое число, возвращайте минимальное количество положительных деци-двоичных чисел, необходимых для того, чтобы они суммировались до n.

Пример 1:

Input: n = "32"

Output: 3

Объяснение: 10 + 11 + 11 = 32

Пример 2:

Input: n = "82734"

Output: 8

Пример 3:

Input: n = "27346209830709182346"

Output: 9

Constraints:

- 1 <= n.length <= 105
- n consists of only digits.
- n does not contain any leading zeros and represents a positive integer.

<https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/>

## 16. Запросы подпрямоугольника
Реализуйте класс SubrectangleQueries, который принимает прямоугольник rows x cols в качестве матрицы целых чисел в конструкторе и поддерживает два метода:

\1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)

- Обновляет все значения с newValue в подпрямоугольнике, верхняя левая координата которого (row1, col1), а нижняя правая (row2, col2).

\2. getValue(int row, int col)

- Возвращает текущее значение координаты (row, col) из прямоугольника.

Пример 1:

Input

["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue","getValue"]

[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]

Output

[null,1,null,5,5,null,10,5]

Объяснение:

SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);

// Начальный прямоугольник (4х3) выглядит так::

// 1 2 1

// 4 3 4

// 3 2 1

// 1 1 1

subrectangleQueries.getValue(0, 2); // return 1

subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);

// После этого обновления прямоугольник выглядит следующим образом:

// 5 5 5

// 5 5 5

// 5 5 5

// 5 5 5

subrectangleQueries.getValue(0, 2); // return 5

subrectangleQueries.getValue(3, 1); // return 5

subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);

// После этого обновления прямоугольник выглядит следующим образом:

// 5   5   5

// 5   5   5

// 5   5   5

// 10  10  10

subrectangleQueries.getValue(3, 1); // return 10

subrectangleQueries.getValue(0, 2); // return 5

Пример 2:

Input

["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue"]

[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]

Output

[null,1,null,100,100,null,20]

Объяснение:

SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);

subrectangleQueries.getValue(0, 0); // return 1

subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);

subrectangleQueries.getValue(0, 0); // return 100

subrectangleQueries.getValue(2, 2); // return 100

subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);

subrectangleQueries.getValue(2, 2); // return 20

Constraints:

- Будет не более 500 операций, учитывая оба метода: updateSubrectangle и getValue.
- 1 <= rows, cols <= 100
- rows == rectangle.length
- cols == rectangle[i].length
- 0 <= row1 <= row2 < rows
- 0 <= col1 <= col2 < cols
- 1 <= newValue, rectangle[i][j] <= 10^9
- 0 <= row < rows
- 0 <= col < cols

<https://leetcode.com/problems/subrectangle-queries/>

## 17. Запросы на количество точек внутри круга
Вам дан массив points, где points[i] = [xi, yi] является координатами i-го точки на плоскости 2D. Несколько точек могут иметь одинаковые координаты.

Вам также дан массив queries, где queries[j] = [xj, yj, rj] описывает круг, центр которого находится в (xj, yj) с радиусом rj.

Для каждого запроса queries[j] вычислите количество точек внутри j-го круга. Точки на границе круга считаются внутри.

Верните массив ответов, где ответ[j] - это ответ на j-й запрос.

Пример 1:

Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]

Output: [3,2,2]

Объяснение: Выше представлены точки и круги. queries[0] - это зеленый круг, queries[1] - это красный круг, а queries[2] - это синий круг.

Пример 2:

Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]

Output: [2,3,2,4]

Объяснение: Выше показаны точки и круги. queries[0] зеленый, queries[1] красный, queries[2] синий, а queries[3] фиолетовый.

Constraints:

- 1 <= points.length <= 500
- points[i].length == 2
- 0 <= x​​​​​​i, y​​​​​​i <= 500
- 1 <= queries.length <= 500
- queries[j].length == 3
- 0 <= xj, yj <= 500
- 1 <= rj <= 500
- Все координаты являются целыми числами.



<https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/>

## 18. Сгруппируйте людей в соответствии с размером их группы.
Есть n людей, которые разделены на неизвестное количество групп. Каждый человек имеет уникальный идентификатор от 0 до n-1.

Вам дан массив целых чисел groupSizes, где groupSizes [i] - это размер группы, в которой находится человек i. Например, если groupSizes [1] = 3, то человек 1 должен находиться в группе размером 3.

Верните список групп таким образом, чтобы каждый человек i находился в группе размера groupSizes [i].

Каждый человек должен появиться ровно в одной группе, и каждый человек должен быть в группе. Если есть несколько ответов, верните любой из них. Гарантируется, что для данного входного значения будет по крайней мере одно допустимое решение.

Пример 1:

Input: groupSizes = [3,3,3,3,3,1,3]

Output: [[5],[0,1,2],[3,4,6]]

Объяснение:

Первая группа - [5]. Размер равен 1, а groupSizes [5] = 1.

Вторая группа - [0,1,2]. Размер равен 3, а groupSizes [0] = groupSizes [1] = groupSizes [2] = 3.

Третья группа - [3,4,6]. Размер равен 3, а groupSizes [3] = groupSizes [4] = groupSizes [6] = 3.

Другие возможные решения - [[2,1,6], [5], [0,4,3]] и [[5], [0,6,2], [4,3,1]].

Пример 2:

Input: groupSizes = [2,1,3,3,3,2]

Output: [[1],[0,5],[2,3,4]]

Constraints:

- groupSizes.length == n
- 1 <= n <= 500
- 1 <= groupSizes[i] <= n

<https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/>

## 19. Подсчитать узлы, равные среднему значению поддерева
Дано root  звено бинарного дерева. Верните количество узлов, значение которых равно среднему значению в поддереве.

Примечание:

- Среднее значение из n элементов - это сумма n элементов, поделенная на n и округленная до ближайшего целого.
- Поддерево root - это дерево, состоящее из root и всех его потомков.

Пример 1:

Input: root = [4,8,5,0,1,null,6]

Output: 5

Объяснение:

Для узла со значением 4: среднее в его поддереве (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.

Для узла со значением 5: среднее в его поддереве (5 + 6) / 2 = 11 / 2 = 5.

Для узла со значением 0: среднее в его поддереве 0 / 1 = 0.

Для узла со значением 1: среднее в его поддереве 1 / 1 = 1.

Для узла со значением 6: среднее в его поддереве 6 / 1 = 6.

Пример 2:

Input: root = [1]

Output: 1

Объяснение: Для узла со значением 1: среднее значение его поддерева равно 1 / 1 = 1.

Constraints:

- Количество узлов в дереве находится в диапазоне [1, 1000].
- 0 <= Node.val <= 1000

<https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/>

## 20. Запросы на перестановку с ключом
Дан массив запросов из положительных целых чисел между 1 и m, вам необходимо обработать все запросы [i] (от i = 0 до i = queries.length-1) в соответствии со следующими правилами:

Вначале у вас есть перестановка P = [1,2,3,...,m].

Для текущего i найдите позицию запросов [i] в перестановке P (индексирование с 0) и переместите его в начало перестановки P. Обратите внимание, что позиция запросов [i] в P является результатом для запросов [i].

Верните массив, содержащий результат для данных запросов.

Пример 1:

Input: queries = [3,1,2,1], m = 5

Output: [2,1,2,1]

Объяснение: Запросы обрабатываются следующим образом:

Для i = 0: запросы [i] = 3, P = [1,2,3,4,5], положение 3 в P равно 2, затем мы перемещаем 3 в начало P, получая P = [3,1,2,4,5].

Для i = 1: запросы [i] = 1, P = [3,1,2,4,5], положение 1 в P равно 1, затем мы перемещаем 1 в начало P, получая P = [1,3,2,4,5].

Для i = 2: запросы [i] = 2, P = [1,3,2,4,5], положение 2 в P равно 2, затем мы перемещаем 2 в начало P, получая P = [2,1,3,4,5].

Для i = 3: запросы [i] = 1, P = [2,1,3,4,5], положение 1 в P равно 1, затем мы перемещаем 1 в начало P, получая P = [1,2,3,4,5].

Поэтому массив, содержащий результат, равен [2,1,2,1].

Пример 2:

Input: queries = [4,1,2,2], m = 4

Output: [3,1,2,0]

Пример 3:

Input: queries = [7,5,5,8,3], m = 8

Output: [6,5,0,7,5]

Constraints:

- 1 <= m <= 10^3
- 1 <= queries.length <= m
- 1 <= queries[i] <= m

<https://leetcode.com/problems/queries-on-a-permutation-with-key/>


